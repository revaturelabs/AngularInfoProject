<div class="container">
  <h1 id="intersection-types">Intersection Types</h1>
  <p>An intersection type combines multiple types into one. This allows you to add together existing types to get a single type
    that has all the features you need. For example,
    <code>Person &amp; Serializable &amp; Loggable</code> is a
    <code>Person</code>
    <em>and</em>
    <code>Serializable</code>
    <em>and</em>
    <code>Loggable</code>. That means an object of this type will have all members of all three types.</p>
  <p>You will mostly see intersection types used for mixins and other concepts that don’t fit in the classic object-oriented
    mold. (There are a lot of these in JavaScript!) Here’s a simple example that shows how to create a mixin:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt;(<span class="hljs-params">first: T, second: U</span>): <span class="hljs-title">T</span> &amp; <span class="hljs-title">U</span> </span>&#123;
                <span class="hljs-keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id <span class="hljs-keyword">in</span> first) &#123;
                    (&lt;<span class="hljs-built_in">any</span>&gt;result)[id] = (&lt;<span class="hljs-built_in">any</span>&gt;first)[id];
                &#125;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id <span class="hljs-keyword">in</span> second) &#123;
                    <span class="hljs-keyword">if</span> (!result.hasOwnProperty(id)) &#123;
                        (&lt;<span class="hljs-built_in">any</span>&gt;result)[id] = (&lt;<span class="hljs-built_in">any</span>&gt;second)[id];
                    &#125;
                &#125;
                <span class="hljs-keyword">return</span> result;
            &#125;
        
            <span class="hljs-keyword">class</span> Person &#123;
                <span class="hljs-keyword">constructor</span>(public name: string) &#123; &#125;
            &#125;
            <span class="hljs-keyword">interface</span> Loggable &#123;
                log(): <span class="hljs-built_in">void</span>;
            &#125;
            <span class="hljs-keyword">class</span> ConsoleLogger <span class="hljs-keyword">implements</span> Loggable &#123;
                log() &#123;
                    <span class="hljs-comment">// ...</span>
                &#125;
            &#125;
            <span class="hljs-keyword">var</span> jim = extend(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Jim"</span>), <span class="hljs-keyword">new</span> ConsoleLogger());
            <span class="hljs-keyword">var</span> n = jim.name;
            jim.log();
        </div></code></pre>
  <h1 id="union-types">Union Types</h1>
  <p>Union types are closely related to intersection types, but they are used very differently. Occasionally, you’ll run into
    a library that expects a parameter to be either a
    <code>number</code> or a
    <code>string</code>. For instance, take the following function:</p>
  <pre class="hljs"><code><div>    <span class="hljs-comment">/**
             * Takes a string and adds "padding" to the left.
             * If 'padding' is a string, then 'padding' is appended to the left side.
             * If 'padding' is a number, then that number of spaces is added to the left side.
             */</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">padLeft</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span>, padding: <span class="hljs-built_in">any</span></span>) </span>&#123;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> padding === <span class="hljs-string">"number"</span>) &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(padding + <span class="hljs-number">1</span>).join(<span class="hljs-string">" "</span>) + value;
                &#125;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> padding === <span class="hljs-string">"string"</span>) &#123;
                    <span class="hljs-keyword">return</span> padding + value;
                &#125;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Expected string or number, got '<span class="hljs-subst">$&#123;padding&#125;</span>'.`</span>);
            &#125;
        
            padLeft(<span class="hljs-string">"Hello world"</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// returns "    Hello world"</span>
        </div></code></pre>
  <p>The problem with
    <code>padLeft</code> is that its
    <code>padding</code> parameter is typed as
    <code>any</code>. That means that we can call it with an argument that’s neither a
    <code>number</code> nor a
    <code>string</code>, but TypeScript will be okay with it.</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">let</span> indentedString = padLeft(<span class="hljs-string">"Hello world"</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// passes at compile time, fails at runtime.</span>
        </div></code></pre>
  <p>In traditional object-oriented code, we might abstract over the two types by creating a hierarchy of types. While this
    is much more explicit, it’s also a little bit overkill. One of the nice things about the original version of
    <code>padLeft</code> was that we were able to just pass in primitives. That meant that usage was simple and concise. This new
    approach also wouldn’t help if we were just trying to use a function that already exists elsewhere.</p>
  <p>Instead of
    <code>any</code>, we can use a
    <em>union type</em> for the
    <code>padding</code> parameter:</p>
  <pre class="hljs"><code><div>    <span class="hljs-comment">/**
             * Takes a string and adds "padding" to the left.
             * If 'padding' is a string, then 'padding' is appended to the left side.
             * If 'padding' is a number, then that number of spaces is added to the left side.
             */</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">padLeft</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span>, padding: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>&#123;
                <span class="hljs-comment">// ...</span>
            &#125;
        
            <span class="hljs-keyword">let</span> indentedString = padLeft(<span class="hljs-string">"Hello world"</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// errors during compilation</span>
        </div></code></pre>
  <p>A union type describes a value that can be one of several types. We use the vertical bar (
    <code>|</code>) to separate each type, so
    <code>number | string | boolean</code> is the type of a value that can be a
    <code>number</code>, a
    <code>string</code>, or a
    <code>boolean</code>.</p>
  <p>If we have a value that has a union type, we can only access members that are common to all types in the union.</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">interface</span> Bird &#123;
                fly();
                layEggs();
            &#125;
        
            <span class="hljs-keyword">interface</span> Fish &#123;
                swim();
                layEggs();
            &#125;
        
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSmallPet</span>(<span class="hljs-params"></span>): <span class="hljs-title">Fish</span> | <span class="hljs-title">Bird</span> </span>&#123;
                <span class="hljs-comment">// ...</span>
            &#125;
        
            <span class="hljs-keyword">let</span> pet = getSmallPet();
            pet.layEggs(); <span class="hljs-comment">// okay</span>
            pet.swim();    <span class="hljs-comment">// errors</span>
        </div></code></pre>
  <p>Union types can be a bit tricky here, but it just takes a bit of intuition to get used to. If a value has the type
    <code>A | B</code>, we only know for
    <em>certain</em> that it has members that both
    <code>A</code>
    <em>and</em>
    <code>B</code> have. In this example,
    <code>Bird</code> has a member named
    <code>fly</code>. We can’t be sure whether a variable typed as
    <code>Bird | Fish</code> has a
    <code>fly</code> method. If the variable is really a
    <code>Fish</code> at runtime, then calling
    <code>pet.fly()</code> will fail.</p>
  <h1 id="type-guards-and-differentiating-types">Type Guards and Differentiating Types</h1>
  <p>Union types are useful for modeling situations when values can overlap in the types they can take on. What happens when
    we need to know specifically whether we have a
    <code>Fish</code>? A common idiom in JavaScript to differentiate between two possible values is to check for the presence of
    a member. As we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">let</span> pet = getSmallPet();
        
            <span class="hljs-comment">// Each of these property accesses will cause an error</span>
            <span class="hljs-keyword">if</span> (pet.swim) &#123;
                pet.swim();
            &#125;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pet.fly) &#123;
                pet.fly();
            &#125;
        </div></code></pre>
  <p>To get the same code working, we’ll need to use a type assertion:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">let</span> pet = getSmallPet();
        
            <span class="hljs-keyword">if</span> ((&lt;Fish&gt;pet).swim) &#123;
                (&lt;Fish&gt;pet).swim();
            &#125;
            <span class="hljs-keyword">else</span> &#123;
                (&lt;Bird&gt;pet).fly();
            &#125;
        </div></code></pre>
  <h2 id="user-defined-type-guards">User-Defined Type Guards</h2>
  <p>Notice that we had to use type assertions several times. It would be much better if once we performed the check, we could
    know the type of
    <code>pet</code> within each branch.</p>
  <p>It just so happens that TypeScript has something called a
    <em>type guard</em>. A type guard is some expression that performs a runtime check that guarantees the type in some scope.
    To define a type guard, we simply need to define a function whose return type is a
    <em>type predicate</em>:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFish</span>(<span class="hljs-params">pet: Fish | Bird</span>): <span class="hljs-title">pet</span> <span class="hljs-title">is</span> <span class="hljs-title">Fish</span> </span>&#123;
                <span class="hljs-keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="hljs-literal">undefined</span>;
            &#125;
        </div></code></pre>
  <p>
    <code>pet is Fish</code> is our type predicate in this example. A predicate takes the form
    <code>parameterName is Type</code>, where
    <code>parameterName</code> must be the name of a parameter from the current function signature.</p>
  <p>Any time
    <code>isFish</code> is called with some variable, TypeScript will
    <em>narrow</em> that variable to that specific type if the original type is compatible.</p>
  <pre class="hljs"><code><div>    <span class="hljs-comment">// Both calls to 'swim' and 'fly' are now okay.</span>
        
            <span class="hljs-keyword">if</span> (isFish(pet)) &#123;
                pet.swim();
            &#125;
            <span class="hljs-keyword">else</span> &#123;
                pet.fly();
            &#125;
        </div></code></pre>
  <p>Notice that TypeScript not only knows that
    <code>pet</code> is a
    <code>Fish</code> in the
    <code>if</code> branch; it also knows that in the
    <code>else</code> branch, you
    <em>don’t</em> have a
    <code>Fish</code>, so you must have a
    <code>Bird</code>.</p>
  <h2 id="typeof-type-guards">
    <code>typeof</code> type guards</h2>
  <p>Let’s go back and write the code for the version of
    <code>padLeft</code> that uses union types. We could write it with type predicates as follows:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">number</span> </span>&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">"number"</span>;
            &#125;
        
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isString</span>(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">string</span> </span>&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">"string"</span>;
            &#125;
        
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">padLeft</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span>, padding: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>&#123;
                <span class="hljs-keyword">if</span> (isNumber(padding)) &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(padding + <span class="hljs-number">1</span>).join(<span class="hljs-string">" "</span>) + value;
                &#125;
                <span class="hljs-keyword">if</span> (isString(padding)) &#123;
                    <span class="hljs-keyword">return</span> padding + value;
                &#125;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Expected string or number, got '<span class="hljs-subst">$&#123;padding&#125;</span>'.`</span>);
            &#125;
        </div></code></pre>
  <p>However, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don’t need
    to abstract
    <code>typeof x === &quot;number&quot;</code> into its own function because TypeScript will recognize it as a type guard on
    its own. That means we could just write these checks inline.</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">padLeft</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span>, padding: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>&#123;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> padding === <span class="hljs-string">"number"</span>) &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(padding + <span class="hljs-number">1</span>).join(<span class="hljs-string">" "</span>) + value;
                &#125;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> padding === <span class="hljs-string">"string"</span>) &#123;
                    <span class="hljs-keyword">return</span> padding + value;
                &#125;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Expected string or number, got '<span class="hljs-subst">$&#123;padding&#125;</span>'.`</span>);
            &#125;
        </div></code></pre>
  <p>These
    <em>
      <code>typeof</code> type guards</em> are recognized in two different forms:
    <code>typeof v === &quot;typename&quot;</code> and
    <code>typeof v !== &quot;typename&quot;</code>, where
    <code>&quot;typename&quot;</code> must be
    <code>&quot;number&quot;</code>,
    <code>&quot;string&quot;</code>,
    <code>&quot;boolean&quot;</code>, or
    <code>&quot;symbol&quot;</code>. While TypeScript won’t stop you from comparing to other strings, the language won’t recognize
    those expressions as type guards.</p>
  <h2 id="instanceof-type-guards">
    <code>instanceof</code> type guards</h2>
  <p>If you’ve read about
    <code>typeof</code> type guards and are familiar with the
    <code>instanceof</code> operator in JavaScript, you probably have some idea of what this section is about.</p>
  <p>
    <em>
      <code>instanceof</code> type guards</em> are a way of narrowing types using their constructor function. For instance, let’s
    borrow our industrial string-padder example from earlier:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">interface</span> Padder &#123;
                getPaddingString(): <span class="hljs-built_in">string</span>
            &#125;
        
            <span class="hljs-keyword">class</span> SpaceRepeatingPadder <span class="hljs-keyword">implements</span> Padder &#123;
                <span class="hljs-keyword">constructor</span>(private numSpaces: number) &#123; &#125;
                getPaddingString() &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">this</span>.numSpaces + <span class="hljs-number">1</span>).join(<span class="hljs-string">" "</span>);
                &#125;
            &#125;
        
            <span class="hljs-keyword">class</span> StringPadder <span class="hljs-keyword">implements</span> Padder &#123;
                <span class="hljs-keyword">constructor</span>(private value: string) &#123; &#125;
                getPaddingString() &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;
                &#125;
            &#125;
        
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandomPadder</span>(<span class="hljs-params"></span>) </span>&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span> ?
                    <span class="hljs-keyword">new</span> SpaceRepeatingPadder(<span class="hljs-number">4</span>) :
                    <span class="hljs-keyword">new</span> StringPadder(<span class="hljs-string">"  "</span>);
            &#125;
        
            <span class="hljs-comment">// Type is 'SpaceRepeatingPadder | StringPadder'</span>
            <span class="hljs-keyword">let</span> padder: Padder = getRandomPadder();
        
            <span class="hljs-keyword">if</span> (padder <span class="hljs-keyword">instanceof</span> SpaceRepeatingPadder) &#123;
                padder; <span class="hljs-comment">// type narrowed to 'SpaceRepeatingPadder'</span>
            &#125;
            <span class="hljs-keyword">if</span> (padder <span class="hljs-keyword">instanceof</span> StringPadder) &#123;
                padder; <span class="hljs-comment">// type narrowed to 'StringPadder'</span>
            &#125;
        </div></code></pre>
  <p>The right side of the
    <code>instanceof</code> needs to be a constructor function, and TypeScript will narrow down to:</p>
  <ol>
    <li>the type of the function’s
      <code>prototype</code> property if its type is not
      <code>any</code>
    </li>
    <li>the union of types returned by that type’s construct signatures</li>
  </ol>
  <p>in that order.</p>
  <h1 id="nullable-types">Nullable types</h1>
  <p>TypeScript has two special types,
    <code>null</code> and
    <code>undefined</code>, that have the values null and undefined respectively. We mentioned these briefly in
    <a href="./basic-types.html">the Basic Types section</a>. By default, the type checker considers
    <code>null</code> and
    <code>undefined</code> assignable to anything. Effectively,
    <code>null</code> and
    <code>undefined</code> are valid values of every type. That means it’s not possible to
    <em>stop</em> them from being assigned to any type, even when you would like to prevent it. The inventor of
    <code>null</code>, Tony Hoare, calls this his
    <a href="https://en.wikipedia.org/wiki/Null_pointer#History">“billion dollar mistake”</a>.</p>
  <p>The
    <code>--strictNullChecks</code> flag fixes this: when you declare a variable, it doesn’t automatically include
    <code>null</code> or
    <code>undefined</code>. You can include them explicitly using a union type:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">let</span> s = <span class="hljs-string">"foo"</span>;
            s = <span class="hljs-literal">null</span>; <span class="hljs-comment">// error, 'null' is not assignable to 'string'</span>
            <span class="hljs-keyword">let</span> sn: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> = <span class="hljs-string">"bar"</span>;
            sn = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ok</span>
        
            sn = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// error, 'undefined' is not assignable to 'string | null'</span>
        </div></code></pre>
  <p>Note that TypeScript treats
    <code>null</code> and
    <code>undefined</code> differently in order to match JavaScript semantics.
    <code>string | null</code> is a different type than
    <code>string | undefined</code> and
    <code>string | undefined | null</code>.</p>
  <h2 id="optional-parameters-and-properties">Optional parameters and properties</h2>
  <p>With
    <code>--strictNullChecks</code>, an optional parameter automatically adds
    <code>| undefined</code>:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y?: <span class="hljs-built_in">number</span></span>) </span>&#123;
                <span class="hljs-keyword">return</span> x + (y || <span class="hljs-number">0</span>);
            &#125;
            f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
            f(<span class="hljs-number">1</span>);
            f(<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>);
            f(<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// error, 'null' is not assignable to 'number | undefined'</span>
        </div></code></pre>
  <p>The same is true for optional properties:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">class</span> C &#123;
                a: <span class="hljs-built_in">number</span>;
                b?: <span class="hljs-built_in">number</span>;
            &#125;
            <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> C();
            c.a = <span class="hljs-number">12</span>;
            c.a = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// error, 'undefined' is not assignable to 'number'</span>
            c.b = <span class="hljs-number">13</span>;
            c.b = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// ok</span>
            c.b = <span class="hljs-literal">null</span>; <span class="hljs-comment">// error, 'null' is not assignable to 'number | undefined'</span>
        </div></code></pre>
  <h2 id="type-guards-and-type-assertions">Type guards and type assertions</h2>
  <p>Since nullable types are implemented with a union, you need to use a type guard to get rid of the
    <code>null</code>. Fortunately, this is the same code you’d write in JavaScript:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">sn: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title">string</span> </span>&#123;
                <span class="hljs-keyword">if</span> (sn == <span class="hljs-literal">null</span>) &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-string">"default"</span>;
                &#125;
                <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">return</span> sn;
                &#125;
            &#125;
        </div></code></pre>
  <p>The
    <code>null</code> elimination is pretty obvious here, but you can use terser operators too:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">sn: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title">string</span> </span>&#123;
                <span class="hljs-keyword">return</span> sn || <span class="hljs-string">"default"</span>;
            &#125;
        </div></code></pre>
  <p>In cases where the compiler can’t eliminate
    <code>null</code> or
    <code>undefined</code>, you can use the type assertion operator to manually remove them. The syntax is postfix
    <code>!</code>:
    <code>identifier!</code> removes
    <code>null</code> and
    <code>undefined</code> from the type of
    <code>identifier</code>:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">broken</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title">string</span> </span>&#123;
              <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postfix</span>(<span class="hljs-params">epithet: <span class="hljs-built_in">string</span></span>) </span>&#123;
                <span class="hljs-keyword">return</span> name.charAt(<span class="hljs-number">0</span>) + <span class="hljs-string">'.  the '</span> + epithet; <span class="hljs-comment">// error, 'name' is possibly null</span>
              &#125;
              name = name || <span class="hljs-string">"Bob"</span>;
              <span class="hljs-keyword">return</span> postfix(<span class="hljs-string">"great"</span>);
            &#125;
        
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fixed</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title">string</span> </span>&#123;
              <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postfix</span>(<span class="hljs-params">epithet: <span class="hljs-built_in">string</span></span>) </span>&#123;
                <span class="hljs-keyword">return</span> name!.charAt(<span class="hljs-number">0</span>) + <span class="hljs-string">'.  the '</span> + epithet; <span class="hljs-comment">// ok</span>
              &#125;
              name = name || <span class="hljs-string">"Bob"</span>;
              <span class="hljs-keyword">return</span> postfix(<span class="hljs-string">"great"</span>);
            &#125;
        </div></code></pre>
  <p>The example uses a nested function here because the compiler can’t eliminate nulls inside a nested function (except immediately-invoked
    function expressions). That’s because it can’t track all calls to the nested function, especially if you return it from
    the outer function. Without knowing where the function is called, it can’t know what the type of
    <code>name</code> will be at the time the body executes.</p>
  <h1 id="type-aliases">Type Aliases</h1>
  <p>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions,
    tuples, and any other types that you’d otherwise have to write by hand.</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Name = <span class="hljs-built_in">string</span>;
            <span class="hljs-keyword">type</span> NameResolver = () =&gt; <span class="hljs-built_in">string</span>;
            <span class="hljs-keyword">type</span> NameOrResolver = Name | NameResolver;
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params">n: NameOrResolver</span>): <span class="hljs-title">Name</span> </span>&#123;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> n === <span class="hljs-string">"string"</span>) &#123;
                    <span class="hljs-keyword">return</span> n;
                &#125;
                <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">return</span> n();
                &#125;
            &#125;
        </div></code></pre>
  <p>Aliasing doesn’t actually create a new type - it creates a new
    <em>name</em> to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.</p>
  <p>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side
    of the alias declaration:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Container&lt;T&gt; = &#123; value: T &#125;;
        </div></code></pre>
  <p>We can also have a type alias refer to itself in a property:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Tree&lt;T&gt; = &#123;
                value: T;
                left: Tree&lt;T&gt;;
                right: Tree&lt;T&gt;;
            &#125;
        </div></code></pre>
  <p>Together with intersection types, we can make some pretty mind-bending types:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;
        
            <span class="hljs-keyword">interface</span> Person &#123;
                name: <span class="hljs-built_in">string</span>;
            &#125;
        
            <span class="hljs-keyword">var</span> people: LinkedList&lt;Person&gt;;
            <span class="hljs-keyword">var</span> s = people.name;
            <span class="hljs-keyword">var</span> s = people.next.name;
            <span class="hljs-keyword">var</span> s = people.next.next.name;
            <span class="hljs-keyword">var</span> s = people.next.next.next.name;
        </div></code></pre>
  <p>However, it’s not possible for a type alias to appear anywhere else on the right side of the declaration:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Yikes = <span class="hljs-built_in">Array</span>&lt;Yikes&gt;; <span class="hljs-comment">// error</span>
        </div></code></pre>
  <h2 id="interfaces-vs-type-aliases">Interfaces vs. Type Aliases</h2>
  <p>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</p>
  <p>One difference is that interfaces create a new name that is used everywhere. Type aliases don’t create a new name — for
    instance, error messages won’t use the alias name. In the code below, hovering over
    <code>interfaced</code> in an editor will show that it returns an
    <code>Interface</code>, but will show that
    <code>aliased</code> returns object literal type.</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Alias = &#123; num: <span class="hljs-built_in">number</span> &#125;
            <span class="hljs-keyword">interface</span> Interface &#123;
                num: <span class="hljs-built_in">number</span>;
            &#125;
            <span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aliased</span>(<span class="hljs-params">arg: Alias</span>): <span class="hljs-title">Alias</span></span>;
            <span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">interfaced</span>(<span class="hljs-params">arg: Interface</span>): <span class="hljs-title">Interface</span></span>;
        </div></code></pre>
  <p>A second more important difference is that type aliases cannot be extended or implemented from (nor can they extend/implement
    other types). Because
    <a href="https://en.wikipedia.org/wiki/Open/closed_principle">an ideal property of software is being open to extension</a>, you should always use an interface over a type alias if
    possible.</p>
  <p>On the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases
    are usually the way to go.</p>
  <h1 id="string-literal-types">String Literal Types</h1>
  <p>String literal types allow you to specify the exact value a string must have. In practice string literal types combine
    nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior
    with strings.</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Easing = <span class="hljs-string">"ease-in"</span> | <span class="hljs-string">"ease-out"</span> | <span class="hljs-string">"ease-in-out"</span>;
            <span class="hljs-keyword">class</span> UIElement &#123;
                animate(dx: <span class="hljs-built_in">number</span>, dy: <span class="hljs-built_in">number</span>, easing: Easing) &#123;
                    <span class="hljs-keyword">if</span> (easing === <span class="hljs-string">"ease-in"</span>) &#123;
                        <span class="hljs-comment">// ...</span>
                    &#125;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (easing === <span class="hljs-string">"ease-out"</span>) &#123;
                    &#125;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (easing === <span class="hljs-string">"ease-in-out"</span>) &#123;
                    &#125;
                    <span class="hljs-keyword">else</span> &#123;
                        <span class="hljs-comment">// error! should not pass null or undefined.</span>
                    &#125;
                &#125;
            &#125;
        
            <span class="hljs-keyword">let</span> button = <span class="hljs-keyword">new</span> UIElement();
            button.animate(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"ease-in"</span>);
            button.animate(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"uneasy"</span>); <span class="hljs-comment">// error: "uneasy" is not allowed here</span>
        </div></code></pre>
  <p>You can pass any of the three allowed strings, but any other string will give the error</p>
  <pre><code>Argument of type '&quot;uneasy&quot;' is not assignable to parameter of type '&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;'
        </code></pre>
  <p>String literal types can be used in the same way to distinguish overloads:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>(<span class="hljs-params">tagName: "img"</span>): <span class="hljs-title">HTMLImageElement</span></span>;
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>(<span class="hljs-params">tagName: "input"</span>): <span class="hljs-title">HTMLInputElement</span></span>;
            <span class="hljs-comment">// ... more overloads ...</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>(<span class="hljs-params">tagName: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Element</span> </span>&#123;
                <span class="hljs-comment">// ... code goes here ...</span>
            &#125;
        </div></code></pre>
  <h1 id="numeric-literal-types">Numeric Literal Types</h1>
  <p>TypeScript also has numeric literal types.</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rollDie</span>(<span class="hljs-params"></span>): 1 | 2 | 3 | 4 | 5 | 6 </span>&#123;
                <span class="hljs-comment">// ...</span>
            &#125;
        </div></code></pre>
  <p>These are seldom written explicitly, they can be useful when narrowing can catch bugs:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) </span>&#123;
                <span class="hljs-keyword">if</span> (x !== <span class="hljs-number">1</span> || x !== <span class="hljs-number">2</span>) &#123;
                    <span class="hljs-comment">//         ~~~~~~~</span>
                    <span class="hljs-comment">// Operator '!==' cannot be applied to types '1' and '2'.</span>
                &#125;
            &#125;
        </div></code></pre>
  <p>In other words,
    <code>x</code> must be
    <code>1</code> when it gets compared to
    <code>2</code>, meaning that the above check is making an invalid comparison.</p>
  <h1 id="enum-member-types">Enum Member Types</h1>
  <p>As mentioned in
    <a href="./enums.html#union-enums-and-enum-member-types">our section on enums</a>, enum members have types when every member is literal-initialized.</p>
  <p>Much of the time when we talk about “singleton types”, we’re referring to both enum member types as well as numeric/string
    literal types, though many users will use “singleton types” and “literal types” interchangeably.</p>
  <h1 id="discriminated-unions">Discriminated Unions</h1>
  <p>You can combine singleton types, union types, type guards, and type aliases to build an advanced pattern called
    <em>discriminated unions</em>, also known as
    <em>tagged unions</em> or
    <em>algebraic data types</em>. Discriminated unions are useful in functional programming. Some languages automatically discriminate
    unions for you; TypeScript instead builds on JavaScript patterns as they exist today. There are three ingredients:</p>
  <ol>
    <li>Types that have a common, singleton type property — the
      <em>discriminant</em>.</li>
    <li>A type alias that takes the union of those types — the
      <em>union</em>.</li>
    <li>Type guards on the common property.</li>
  </ol>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">interface</span> Square &#123;
                kind: <span class="hljs-string">"square"</span>;
                size: <span class="hljs-built_in">number</span>;
            &#125;
            <span class="hljs-keyword">interface</span> Rectangle &#123;
                kind: <span class="hljs-string">"rectangle"</span>;
                width: <span class="hljs-built_in">number</span>;
                height: <span class="hljs-built_in">number</span>;
            &#125;
            <span class="hljs-keyword">interface</span> Circle &#123;
                kind: <span class="hljs-string">"circle"</span>;
                radius: <span class="hljs-built_in">number</span>;
            &#125;
        </div></code></pre>
  <p>First we declare the interfaces we will union. Each interface has a
    <code>kind</code> property with a different string literal type. The
    <code>kind</code> property is called the
    <em>discriminant</em> or
    <em>tag</em>. The other properties are specific to each interface. Notice that the interfaces are currently unrelated. Let’s
    put them into a union:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Shape = Square | Rectangle | Circle;
        </div></code></pre>
  <p>Now let’s use the discriminated union:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">area</span>(<span class="hljs-params">s: Shape</span>) </span>&#123;
                <span class="hljs-keyword">switch</span> (s.kind) &#123;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"square"</span>: <span class="hljs-keyword">return</span> s.size * s.size;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"rectangle"</span>: <span class="hljs-keyword">return</span> s.height * s.width;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"circle"</span>: <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.PI * s.radius ** <span class="hljs-number">2</span>;
                &#125;
            &#125;
        </div></code></pre>
  <h2 id="exhaustiveness-checking">Exhaustiveness checking</h2>
  <p>We would like the compiler to tell us when we don’t cover all variants of the discriminated union. For example, if we add
    <code>Triangle</code> to
    <code>Shape</code>, we need to update
    <code>area</code> as well:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Shape = Square | Rectangle | Circle | Triangle;
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">area</span>(<span class="hljs-params">s: Shape</span>) </span>&#123;
                <span class="hljs-keyword">switch</span> (s.kind) &#123;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"square"</span>: <span class="hljs-keyword">return</span> s.size * s.size;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"rectangle"</span>: <span class="hljs-keyword">return</span> s.height * s.width;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"circle"</span>: <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.PI * s.radius ** <span class="hljs-number">2</span>;
                &#125;
                <span class="hljs-comment">// should error here - we didn't handle case "triangle"</span>
            &#125;
        </div></code></pre>
  <p>There are two ways to do this. The first is to turn on
    <code>--strictNullChecks</code> and specify a return type:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">area</span>(<span class="hljs-params">s: Shape</span>): <span class="hljs-title">number</span> </span>&#123; <span class="hljs-comment">// error: returns number | undefined</span>
                <span class="hljs-keyword">switch</span> (s.kind) &#123;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"square"</span>: <span class="hljs-keyword">return</span> s.size * s.size;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"rectangle"</span>: <span class="hljs-keyword">return</span> s.height * s.width;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"circle"</span>: <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.PI * s.radius ** <span class="hljs-number">2</span>;
                &#125;
            &#125;
        </div></code></pre>
  <p>Because the
    <code>switch</code> is no longer exhaustive, TypeScript is aware that the function could sometimes return
    <code>undefined</code>. If you have an explicit return type
    <code>number</code>, then you will get an error that the return type is actually
    <code>number | undefined</code>. However, this method is quite subtle and, besides,
    <code>--strictNullChecks</code> does not always work with old code.</p>
  <p>The second method uses the
    <code>never</code> type that the compiler uses to check for exhaustiveness:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertNever</span>(<span class="hljs-params">x: never</span>): <span class="hljs-title">never</span> </span>&#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unexpected object: "</span> + x);
            &#125;
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">area</span>(<span class="hljs-params">s: Shape</span>) </span>&#123;
                <span class="hljs-keyword">switch</span> (s.kind) &#123;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"square"</span>: <span class="hljs-keyword">return</span> s.size * s.size;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"rectangle"</span>: <span class="hljs-keyword">return</span> s.height * s.width;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"circle"</span>: <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.PI * s.radius ** <span class="hljs-number">2</span>;
                    <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> assertNever(s); <span class="hljs-comment">// error here if there are missing cases</span>
                &#125;
            &#125;
        </div></code></pre>
  <p>Here,
    <code>assertNever</code> checks that
    <code>s</code> is of type
    <code>never</code> — the type that’s left after all other cases have been removed. If you forget a case, then
    <code>s</code> will have a real type and you will get a type error. This method requires you to define an extra function, but
    it’s much more obvious when you forget it.</p>
  <h1 id="polymorphic-this-types">Polymorphic
    <code>this</code> types</h1>
  <p>A polymorphic
    <code>this</code> type represents a type that is the
    <em>subtype</em> of the containing class or interface. This is called
    <em>F</em>-bounded polymorphism. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple
    calculator that returns
    <code>this</code> after each operation:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">class</span> BasicCalculator &#123;
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(protected value: number = 0) &#123; &#125;
                <span class="hljs-keyword">public</span> currentValue(): <span class="hljs-built_in">number</span> &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;
                &#125;
                <span class="hljs-keyword">public</span> add(operand: <span class="hljs-built_in">number</span>): <span class="hljs-keyword">this</span> &#123;
                    <span class="hljs-keyword">this</span>.value += operand;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
                &#125;
                <span class="hljs-keyword">public</span> multiply(operand: <span class="hljs-built_in">number</span>): <span class="hljs-keyword">this</span> &#123;
                    <span class="hljs-keyword">this</span>.value *= operand;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
                &#125;
                <span class="hljs-comment">// ... other operations go here ...</span>
            &#125;
        
            <span class="hljs-keyword">let</span> v = <span class="hljs-keyword">new</span> BasicCalculator(<span class="hljs-number">2</span>)
                        .multiply(<span class="hljs-number">5</span>)
                        .add(<span class="hljs-number">1</span>)
                        .currentValue();
        </div></code></pre>
  <p>Since the class uses
    <code>this</code> types, you can extend it and the new class can use the old methods with no changes.</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">class</span> ScientificCalculator extends BasicCalculator &#123;
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(value = 0) &#123;
                    <span class="hljs-keyword">super</span>(value);
                &#125;
                <span class="hljs-keyword">public</span> sin() &#123;
                    <span class="hljs-keyword">this</span>.value = <span class="hljs-built_in">Math</span>.sin(<span class="hljs-keyword">this</span>.value);
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
                &#125;
                <span class="hljs-comment">// ... other operations go here ...</span>
            &#125;
        
            <span class="hljs-keyword">let</span> v = <span class="hljs-keyword">new</span> ScientificCalculator(<span class="hljs-number">2</span>)
                    .multiply(<span class="hljs-number">5</span>)
                    .sin()
                    .add(<span class="hljs-number">1</span>)
                    .currentValue();
        </div></code></pre>
  <p>Without
    <code>this</code> types,
    <code>ScientificCalculator</code> would not have been able to extend
    <code>BasicCalculator</code> and keep the fluent interface.
    <code>multiply</code> would have returned
    <code>BasicCalculator</code>, which doesn’t have the
    <code>sin</code> method. However, with
    <code>this</code> types,
    <code>multiply</code> returns
    <code>this</code>, which is
    <code>ScientificCalculator</code> here.</p>
  <h1 id="index-types">Index types</h1>
  <p>With index types, you can get the compiler to check code that uses dynamic property names. For example, a common Javascript
    pattern is to pick a subset of properties from an object:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pluck</span>(<span class="hljs-params">o, names</span>) </span>&#123;
                <span class="hljs-keyword">return</span> names.map(n =&gt; o[n]);
            &#125;
        </div></code></pre>
  <p>Here’s how you would write and use this function in TypeScript, using the
    <strong>index type query</strong> and
    <strong>indexed access</strong> operators:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pluck</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">o: T, names: K[]</span>): <span class="hljs-title">T</span>[<span class="hljs-title">K</span>][] </span>&#123;
              <span class="hljs-keyword">return</span> names.map(n =&gt; o[n]);
            &#125;
        
            <span class="hljs-keyword">interface</span> Person &#123;
                name: <span class="hljs-built_in">string</span>;
                age: <span class="hljs-built_in">number</span>;
            &#125;
            <span class="hljs-keyword">let</span> person: Person = &#123;
                name: <span class="hljs-string">'Jarid'</span>,
                age: <span class="hljs-number">35</span>
            &#125;;
            <span class="hljs-keyword">let</span> strings: <span class="hljs-built_in">string</span>[] = pluck(person, [<span class="hljs-string">'name'</span>]); <span class="hljs-comment">// ok, string[]</span>
        </div></code></pre>
  <p>The compiler checks that
    <code>name</code> is actually a property on
    <code>Person</code>. The example introduces a couple of new type operators. First is
    <code>keyof T</code>, the
    <strong>index type query operator</strong>. For any type
    <code>T</code>,
    <code>keyof T</code> is the union of known, public property names of
    <code>T</code>. For example:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">let</span> personProps: keyof Person; <span class="hljs-comment">// 'name' | 'age'</span>
        </div></code></pre>
  <p>
    <code>keyof Person</code> is completely interchangeable with
    <code>'name' | 'age'</code>. The difference is that if you add another property to
    <code>Person</code>, say
    <code>address: string</code>, then
    <code>keyof Person</code> will automatically update to be
    <code>'name' | 'age' | 'address'</code>. And you can use
    <code>keyof</code> in generic contexts like
    <code>pluck</code>, where you can’t possibly know the property names ahead of time. That means the compiler will check that
    you pass the right set of property names to
    <code>pluck</code>:</p>
  <pre class="hljs"><code><div>    pluck(person, [<span class="hljs-string">'age'</span>, <span class="hljs-string">'unknown'</span>]); <span class="hljs-comment">// error, 'unknown' is not in 'name' | 'age'</span>
        </div></code></pre>
  <p>The second operator is
    <code>T[K]</code>, the
    <strong>indexed access operator</strong>. Here, the type syntax reflects the expression syntax. That means that
    <code>person['name']</code> has the type
    <code>Person['name']</code> — which in our example is just
    <code>string</code>. However, just like index type queries, you can use
    <code>T[K]</code> in a generic context, which is where its real power comes to life. You just have to make sure that the type
    variable
    <code>K extends keyof T</code>. Here’s another example with a function named
    <code>getProperty</code>.</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProperty</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">o: T, name: K</span>): <span class="hljs-title">T</span>[<span class="hljs-title">K</span>] </span>&#123;
                <span class="hljs-keyword">return</span> o[name]; <span class="hljs-comment">// o[name] is of type T[K]</span>
            &#125;
        </div></code></pre>
  <p>In
    <code>getProperty</code>,
    <code>o: T</code> and
    <code>name: K</code>, so that means
    <code>o[name]: T[K]</code>. Once you return the
    <code>T[K]</code> result, the compiler will instantiate the actual type of the key, so the return type of
    <code>getProperty</code> will vary according to which property you request.</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">string</span> = getProperty(person, <span class="hljs-string">'name'</span>);
            <span class="hljs-keyword">let</span> age: <span class="hljs-built_in">number</span> = getProperty(person, <span class="hljs-string">'age'</span>);
            <span class="hljs-keyword">let</span> unknown = getProperty(person, <span class="hljs-string">'unknown'</span>); <span class="hljs-comment">// error, 'unknown' is not in 'name' | 'age'</span>
        </div></code></pre>
  <h2 id="index-types-and-string-index-signatures">Index types and string index signatures</h2>
  <p>
    <code>keyof</code> and
    <code>T[K]</code> interact with string index signatures. If you have a type with a string index signature,
    <code>keyof T</code> will just be
    <code>string</code>. And
    <code>T[string]</code> is just the type of the index signature:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">interface</span> Map&lt;T&gt; &#123;
                [key: <span class="hljs-built_in">string</span>]: T;
            &#125;
            <span class="hljs-keyword">let</span> keys: keyof Map&lt;<span class="hljs-built_in">number</span>&gt;; <span class="hljs-comment">// string</span>
            <span class="hljs-keyword">let</span> value: Map&lt;<span class="hljs-built_in">number</span>&gt;[<span class="hljs-string">'foo'</span>]; <span class="hljs-comment">// number</span>
        </div></code></pre>
  <h1 id="mapped-types">Mapped types</h1>
  <p>A common task is to take an existing type and make each of its properties optional:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">interface</span> PersonPartial &#123;
                name?: <span class="hljs-built_in">string</span>;
                age?: <span class="hljs-built_in">number</span>;
            &#125;
        </div></code></pre>
  <p>Or we might want a readonly version:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">interface</span> PersonReadonly &#123;
                readonly name: <span class="hljs-built_in">string</span>;
                readonly age: <span class="hljs-built_in">number</span>;
            &#125;
        </div></code></pre>
  <p>This happens often enough in Javascript that TypeScript provides a way to create new types based on old types —
    <strong>mapped types</strong>. In a mapped type, the new type transforms each property in the old type in the same way. For example,
    you can make all properties of a type
    <code>readonly</code> or optional. Here are a couple of examples:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Readonly&lt;T&gt; = &#123;
                readonly [P <span class="hljs-keyword">in</span> keyof T]: T[P];
            &#125;
            <span class="hljs-keyword">type</span> Partial&lt;T&gt; = &#123;
                [P <span class="hljs-keyword">in</span> keyof T]?: T[P];
            &#125;
        </div></code></pre>
  <p>And to use it:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> PersonPartial = Partial&lt;Person&gt;;
            <span class="hljs-keyword">type</span> ReadonlyPerson = Readonly&lt;Person&gt;;
        </div></code></pre>
  <p>Let’s take a look at the simplest mapped type and its parts:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Keys = <span class="hljs-string">'option1'</span> | <span class="hljs-string">'option2'</span>;
            <span class="hljs-keyword">type</span> Flags = &#123; [K <span class="hljs-keyword">in</span> Keys]: <span class="hljs-built_in">boolean</span> &#125;;
        </div></code></pre>
  <p>The syntax resembles the syntax for index signatures with a
    <code>for .. in</code> inside. There are three parts:</p>
  <ol>
    <li>The type variable
      <code>K</code>, which gets bound to each property in turn.</li>
    <li>The string literal union
      <code>Keys</code>, which contains the names of properties to iterate over.</li>
    <li>The resulting type of the property.</li>
  </ol>
  <p>In this simple example,
    <code>Keys</code> is a hard-coded list of property names and the property type is always
    <code>boolean</code>, so this mapped type is equivalent to writing:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Flags = &#123;
                option1: <span class="hljs-built_in">boolean</span>;
                option2: <span class="hljs-built_in">boolean</span>;
            &#125;
        </div></code></pre>
  <p>Real applications, however, look like
    <code>Readonly</code> or
    <code>Partial</code> above. They’re based on some existing type, and they transform the properties in some way. That’s where
    <code>keyof</code> and indexed access types come in:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> NullablePerson = &#123; [P <span class="hljs-keyword">in</span> keyof Person]: Person[P] | <span class="hljs-literal">null</span> &#125;
            <span class="hljs-keyword">type</span> PartialPerson = &#123; [P <span class="hljs-keyword">in</span> keyof Person]?: Person[P] &#125;
        </div></code></pre>
  <p>But it’s more useful to have a general version.</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Nullable&lt;T&gt; = &#123; [P <span class="hljs-keyword">in</span> keyof T]: T[P] | <span class="hljs-literal">null</span> &#125;
            <span class="hljs-keyword">type</span> Partial&lt;T&gt; = &#123; [P <span class="hljs-keyword">in</span> keyof T]?: T[P] &#125;
        </div></code></pre>
  <p>In these examples, the properties list is
    <code>keyof T</code> and the resulting type is some variant of
    <code>T[P]</code>. This is a good template for any general use of mapped types. That’s because this kind of transformation
    is
    <a href="https://en.wikipedia.org/wiki/Homomorphism">homomorphic</a>, which means that the mapping applies only to properties of
    <code>T</code> and no others. The compiler knows that it can copy all the existing property modifiers before adding any new
    ones. For example, if
    <code>Person.name</code> was readonly,
    <code>Partial&lt;Person&gt;.name</code> would be readonly and optional.</p>
  <p>Here’s one more example, in which
    <code>T[P]</code> is wrapped in a
    <code>Proxy&lt;T&gt;</code> class:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Proxy&lt;T&gt; = &#123;
                <span class="hljs-keyword">get</span>(): T;
                <span class="hljs-keyword">set</span>(value: T): <span class="hljs-built_in">void</span>;
            &#125;
            <span class="hljs-keyword">type</span> Proxify&lt;T&gt; = &#123;
                [P <span class="hljs-keyword">in</span> keyof T]: Proxy&lt;T[P]&gt;;
            &#125;
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxify</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">o: T</span>): <span class="hljs-title">Proxify</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
               <span class="hljs-comment">// ... wrap proxies ...</span>
            &#125;
            <span class="hljs-keyword">let</span> proxyProps = proxify(props);
        </div></code></pre>
  <p>Note that
    <code>Readonly&lt;T&gt;</code> and
    <code>Partial&lt;T&gt;</code> are so useful, they are included in TypeScript’s standard library along with
    <code>Pick</code> and
    <code>Record</code>:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> Pick&lt;T, K extends keyof T&gt; = &#123;
                [P <span class="hljs-keyword">in</span> K]: T[P];
            &#125;
            <span class="hljs-keyword">type</span> Record&lt;K extends <span class="hljs-built_in">string</span>, T&gt; = &#123;
                [P <span class="hljs-keyword">in</span> K]: T;
            &#125;
        </div></code></pre>
  <p>
    <code>Readonly</code>,
    <code>Partial</code> and
    <code>Pick</code> are homomorphic whereas
    <code>Record</code> is not. One clue that
    <code>Record</code> is not homomorphic is that it doesn’t take an input type to copy properties from:</p>
  <pre class="hljs"><code><div>    <span class="hljs-keyword">type</span> ThreeStringProps = Record&lt;<span class="hljs-string">'prop1'</span> | <span class="hljs-string">'prop2'</span> | <span class="hljs-string">'prop3'</span>, <span class="hljs-built_in">string</span>&gt;
        </div></code></pre>
  <p>Non-homomorphic types are essentially creating new properties, so they can’t copy property modifiers from anywhere.</p>
  <h2 id="inference-from-mapped-types">Inference from mapped types</h2>
  <p>Now that you know how to wrap the properties of a type, the next thing you’ll want to do is unwrap them. Fortunately, that’s
    pretty easy:</p>
  <pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unproxify</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">t: Proxify&lt;T&gt;</span>): <span class="hljs-title">T</span> </span>&#123;
                <span class="hljs-keyword">let</span> result = &#123;&#125; as T;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> t) &#123;
                    result[k] = t[k].get();
                &#125;
                <span class="hljs-keyword">return</span> result;
            &#125;
        
            <span class="hljs-keyword">let</span> originalProps = unproxify(proxyProps);
        </div></code></pre>
  <p>Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you’ll
    have to give an explicit type parameter to your unwrapping function.</p>
</div>
